##
# name:      Module::Package::Plugin
# abstract:  Base class for Module::Package author-side plugins
# author:    Ingy d√∂t Net <ingy@cpan.org>
# license:   perl
# copyright: 2011

package Module::Package::Plugin;
use Moo 0.009007;

our $VERSION = '0.12';

use IO::All;

has mi => (is => 'rw');
has options => (
    is => 'rw',
    lazy => 1,
    builder => '_build_options',
);
sub _build_options {
    my ($self) = @_;
    $self->mi->package_options;
}

#-----------------------------------------------------------------------------#
# These 3 functions (initial, main and final) make up the Module::Package
# plugin API. Subclasses MUST override 'main', and should rarely override
# 'initial' and 'final'.
#-----------------------------------------------------------------------------#
sub initial {
    my ($self) = @_;
    # Load pkg/conf.yaml if it exists
    $self->mi->_guess_pm;
    $self->eval_deps_list;
}

sub main {
    my ($self) = @_;
    my $class = ref($self);
    die "$class cannot be used as a Module::Package plugin. Use a subclass"
        if $class eq __PACKAGE__;
    die "$class needs to provide a method called 'main()'";
}

sub final {
    my ($self) = @_;
    $self->manifest_skip;
    $self->mi->_install_bin;
    $self->WriteAll;
    $self->write_deps_list;
}

#-----------------------------------------------------------------------------#
# This is where the useful methods (that author plugins can invoke) live.
#-----------------------------------------------------------------------------#
sub pod_or_pm_file {
    return $main::POD || $main::PM;
}
sub pm_file {
    return $main::PM;
}

my $deps_list_file = 'pkg/deps_list.pl';
sub eval_deps_list {
    my ($self) = @_;
    return if not $self->options->{deps_list};
    my $data = '';
    if (-e 'Makefile.PL') {
        my $text = io('Makefile.PL')->all;
        if ($text =~ /.*\n__(?:DATA|END)__\r?\n(.*)/s) {
            $data = $1;
        }
    }
    if (-e $deps_list_file) {
        package main;
        require $deps_list_file;
    }
    elsif ($data) {
        package main;
        eval $data;
        die $@ if $@;
    }
}

sub write_deps_list {
    my ($self) = @_;
    return if not $self->options->{deps_list};
    my @inc;
    File::Find::find(sub {
        return unless -f $_ and $_ =~ /\.pm$/;
        push @inc, $File::Find::name;
    }, 'inc');
    my $text = '';
    no strict 'refs';
    $text .= join '', map {
        my $version = ${"${_}::VERSION"} || '';
        if ($version) {
            "package_author_requires '$_' => '$version';" . $/;
        }
        else {
            "package_author_requires '$_';" . $/;
        }
    } grep {
        not m!^Module::(Package|Install)$! and
        not m!^Module::Install::(Base|Can|Fetch|Makefile|ManifestSkip|Metadata|Package|Scripts|Win32|WriteAll)$!;
    } map {
        s!inc[\/\\](.*)\.pm$!$1!;
        s!/+!::!g;
        $_;
    } sort @inc;
    $text = <<"..." . $text if $text;

# Deps list generated by Module::Package v$Module::Package::VERSION

...
    if (-e $deps_list_file) {
        my $old_text = io($deps_list_file)->all;
        $text .= "1;" . $/;
        if ($text ne $old_text) {
            warn "Updating $deps_list_file\n";
            io($deps_list_file)->print($text);
        }
    }
    elsif (
        -e 'Makefile.PL' and
        io('Makefile.PL')->all =~ /^__(?:DATA|END)__$/m
    ) {
        my $perl = io('Makefile.PL')->all;
        my $old_perl = $perl;
        $perl =~ s/(.*\n__(?:DATA|END)__\r?\n).*/$1/s or die $perl;
        $perl .= $text;
        if ($perl ne $old_perl) {
            warn "Updating deps_list in Makefile.PL\n";
            io('Makefile.PL')->print($perl);
        }
    }
    elsif ($text) {
        warn <<'...';
Note: Can't find a place to write deps list, and deps_list option is true.
      See 'deps_list' in Module::Package documentation.
...
    }
}

# We generate a MANIFEST.SKIP and add things to it.
# We add pkg/, because that should only contain author stuff.
# We add author only M::I plugins, so they don't get distributed.
sub manifest_skip {
    my ($self) = @_;
    return if not $self->options->{manifest_skip};
    $self->mi->manifest_skip;

    # XXX Hardcoded author list for now. Need to change this.
    # One idea is to let Module::Package plugins declare which plugins are
    # Author-side only.
    io('MANIFEST.SKIP')->append(<<'...');
        print MS <<'...';
^pkg/
^inc/Module/Install/AckXXX.pm$
^inc/Module/Install/ManifestSkip.pm$
^inc/Module/Install/ReadmeFromPod.pm$
^inc/Module/Install/Stardoc.pm$
^inc/Module/Install/VersionCheck.pm$
...

    $self->mi->clean_files('MANIFEST MANIFEST.SKIP');
}


#-----------------------------------------------------------------------------#
# These functions are wrappers around Module::Install functions of the same
# names. They are generally safer (and simpler) to call than the real ones.
# They should almost always be chosen by Module::Package::Plugin subclasses.
#-----------------------------------------------------------------------------#
my $WriteAll = 0;
sub WriteAll {
    return if $WriteAll++;
    my ($self) = @_;
    $self->_replicate;
    $self->mi->WriteAll;
}

my $all_from = 0;
sub all_from {
    return if $all_from++;
    my $self = shift;
    my $file = shift || $main::PM;
    $self->mi->all_from($file);
}

#-----------------------------------------------------------------------------#
# These are ugly housekeeping functions.
#-----------------------------------------------------------------------------#
sub _replicate {
    my $target_file = 'inc/Module/Package.pm';
    if (-e 'inc/.author' and not -e $target_file) {
        my $source_file = $INC{'Module/Package.pm'}
            or die "Can't bootstrap inc::Module::Package";
        Module::Install::Admin->copy($source_file, $target_file);
    }
}

sub _version_check {
    my ($self, $version) = @_;
    die <<"..." unless $version == $VERSION;

Error! Something has gone awry:
    Module::Package version=$version is using 
    Module::Package::Plugin version=$VERSION
If you are the author of this module, try upgrading Module::Package.
Otherwise, please notify the author of this error.

...
}

package Module::Package::Plugin::basic;
use Moo;
extends 'Module::Package::Plugin';

sub main {
    my ($self) = @_;
    $self->all_from;
}

1;
